# The hidden "this" pointer

一个经常被面向对象新手问到的问题，“当一个成员函数被调用时，C++ 是如何追踪是哪个对象被调用了呢？”。答案就是 C++ 利用了一个隐藏的名为 “this” 的指针！

## 被隐藏的 \*this 指针

```cpp
simple.setID(2);
```

尽管调用 `setID()` 函数看起来像是只有一个参数，实际上有两个！当被编译时，编译器转换 `simple.setID(2);` 成为：

```cpp
setID(&simple, 2); // 注意 simple 从前置的一个对象变为了一个函数的入参！
```

注意这仅仅是一个标准的函数调用，同时 simple 对象现在被地址传递成为函数的一个入参。

不过这也只是一半答案。因为函数调用现在有了额外的参数，成员函数定义需要进行修改来接受（并使用）这个参数。结果就是以下的成员函数：

```cpp
void setID(int id) { m_id = id; }
```

被转换为：

```cpp
void setID(Simple* const this, int id) { this->m_id = id; }
```

当编译器编译普通成员函数时，它隐式添加名为“this”的新参数给函数。**this 指针**是一个隐藏的 const 指针用于存储被调用函数的对象的地址。

这里还有一个细节需要关注。那就是在成员函数内部，任何类成员（函数与变量）同样也需要更新，这样它们才能指向被调用成员函数的对象。在它们每个前添加“this ->”前缀很容易。因此函数 `setID()`，`m_id`（类成员变量） 可以被转换为 `this->m_id`。因此当“this”指向 simple 的地址，this->m_id 成为 shimple.m_id。

把它们全部联系起来就是：

1. 当调用 `simple.setID(2)` 时，编译器实际上调用的是 `setID(&simple, 2)`。
1. 在 `setID()` 中，“this”指针存储了 simple 对象的地址。
1. 任何在 `setID()` 中的成员需要“this->”前缀。因此当 `m_id = id` 时，编译器实际上执行的是 `this->m_id = id`，这种情况下将 simple.m_id 更新至 id。

## “this” 总是指向其被操作的对象

```cpp
int main()
{
    Simple A{1};  // this = &A 在 Simple 的构造函数内
    Simple B{2};  // this = &B 在 Simple 的构造函数内
    A.setID(3);   // this = &A 在成员函数 setID 内
    B.setID(4);   // this = &B 在成员函数 setID 内

    return 0;
}
```

## 显式引用“this”

```cpp
class Something
{
private:
    int data;

public:
    Something(int data)
    {
        this->data = data; // this->data 为成员，data 为本地参数
    }
};
```

## 串联成员函数

```cpp
#include <iostream>

class Calc
{
private:
    int m_value{};

public:
    Calc& add(int value) { m_value += value; return *this; }
    Calc& sub(int value) { m_value -= value; return *this; }
    Calc& mult(int value) { m_value *= value; return *this; }

    int getValue() { return m_value; }
};

int main()
{
    Calc calc{};
    calc.add(5).sub(3).mult(4);

    std::cout << calc.getValue() << '\n';
    return 0;
}
```
