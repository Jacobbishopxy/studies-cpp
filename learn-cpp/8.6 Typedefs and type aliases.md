# Typedefs and type aliases

## Type 别名

C++ 中，**using**是一个用于对现有数据类型创建别名的关键词。

```cpp
using Distance = double; // 定义 Distance 实则为 double 类型

Distance milesToDestination{ 3.4 }; // 定义变量
```

## Naming type aliases

历史原因，没有关于类型如何命名的一致性。通常有三种常见的命名转换：

- 类型别名带有 “\_t” 后缀（“type” 的缩写）。这类转换通常用于标准库的全局域类型名称（例如 `size_t` 以及 `nullptr_t`）。

这类转换有 C 继承而来，在用户自定义类型（有时别的类型）别名是尤为常见，但是这不太符合现代 C++ 的习惯。

- 类型别名带有 “\_type” 后缀。这类转换用于一些标准库类型（例如 `std::string`）用于嵌套类型的别名（例如 `std::string::size_type`）。

但是还有一些嵌套类型完全没有后缀（例如 `std::string::iterator`），因此这种用法最好是非连贯的。

- 不带后缀的类型别名。

现代 C++ 中使用无后缀。大写字母可以帮助从变量以及函数名称（小写字母开头）中辨别类型名称，并防止它们命名冲突。

```cpp
void printDistance(Distance distance); // Distance 在别处被定义
```

最佳实践：自定义类型使用大写的方式并且不带后缀（除非有非常特别的原因）。

## 类型别名的作用域

类型别名标识符与变量标识符的作用域相同。如果需要跨文件使用，可以在头文件中定义：

```h
#ifndef MYTYPES
#define MYTYPES

    using Miles = long;
    using Speed = long;

#endif
```

## Typedefs

**typedef**（“type definition” 的缩写）是创建类型别名的旧方法。

```cpp
// The following aliases are identical
typedef long Miles;
using Miles = long;
```

因为向后兼容的原因 Typedefs 仍然在 C++ 中存在，不过在现代 C++ 中，它们已经大量的被类型别名给替换了。

最佳实践：使用类型别名而不是 typedefs。
